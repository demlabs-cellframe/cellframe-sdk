/*************************************************************************************
* qTESLA: an efficient post-quantum signature scheme based on the R-LWE problem
*
* Abstract: sampling functions
**************************************************************************************/

#include "tesla_params.h"

#define round_double(x) (uint64_t)(x + 0.5)

void sample_y(int64_t *y, const unsigned char *seed, int nonce, tesla_param_t *p) { // Sample polynomial y, such that each coefficient is in the range [-B,B]

    unsigned int i = 0, pos = 0, nblocks = p->PARAM_N;
    unsigned int nbytes = ((p->PARAM_B_BITS + 1) + 7) / 8;
    unsigned char *buf = malloc(p->PARAM_N * nbytes * sizeof(char) + 1);
    int16_t dmsp = (int16_t)(nonce << 8);

    uint32_t NBLOCKS_SHAKE = 0;
    if(p->kind == 0 || p->kind == 3) {
      cshake128_simple((uint8_t *) buf, p->PARAM_N * nbytes, dmsp++, seed, CRYPTO_RANDOMBYTES);
//        cSHAKE128( seed, CRYPTO_RANDOMBYTES * 8, (uint8_t *) buf, p->PARAM_N * nbytes * 8, NULL, 0, &dmsp, 16 );
//        ++dmsp;
        NBLOCKS_SHAKE = SHAKE128_RATE / (((p->PARAM_B_BITS + 1) + 7) / 8);
    }
    else {
      cshake256_simple((uint8_t *) buf, p->PARAM_N * nbytes, dmsp++, seed, CRYPTO_RANDOMBYTES);
//        cSHAKE256( seed, CRYPTO_RANDOMBYTES * 8, (uint8_t *) buf, p->PARAM_N * nbytes * 8, NULL, 0, &dmsp, 16 );
//        ++dmsp;
        NBLOCKS_SHAKE = SHAKE256_RATE / (((p->PARAM_B_BITS + 1) + 7) / 8);
    }

    while (i < p->PARAM_N) {
        if (pos >= nblocks * nbytes) {
            if(p->kind == 0 || p->kind == 3) {
                nblocks = NBLOCKS_SHAKE;
              cshake128_simple((uint8_t *) buf, SHAKE128_RATE, dmsp++, seed, CRYPTO_RANDOMBYTES);
//                cSHAKE128( seed, CRYPTO_RANDOMBYTES * 8, (uint8_t *) buf, SHAKE128_RATE * 8, NULL, 0, &dmsp, 16 );
//                ++dmsp;
            }
            else {
                nblocks = NBLOCKS_SHAKE;
                cshake256_simple((uint8_t *) buf, SHAKE256_RATE, dmsp++, seed, CRYPTO_RANDOMBYTES);
//                cSHAKE256( seed, CRYPTO_RANDOMBYTES * 8, (uint8_t *) buf, SHAKE256_RATE * 8, NULL, 0, &dmsp, 16 );
//                ++dmsp;
            }
            pos = 0;
        }
        y[i] = (*(uint32_t *) (buf + pos)) & ((1 << (p->PARAM_B_BITS + 1)) - 1);
        y[i] -= (int64_t)(p->PARAM_B);
        if (y[i] != (1 << p->PARAM_B_BITS))
            i++;
        pos += nbytes;
    }
    free(buf);
    buf = NULL;
}

static int64_t mod7(int64_t k) { // Compute k modulo 7

    int64_t i = k;

    int j;
    for ( j = 0; j < 2; j++) {
        i = (i & 7) + (i >> 3);
    }
    // i <= 7 at this point. If (i == 7) return 0, else return i
    return ((i - 7) >> 3) & i;
}

static uint32_t Bernoulli(int64_t r, int64_t t, tesla_param_t *p) { // Sample a bit from Bernoulli
                                                  // Restriction: 20-bit exponent
    if(p->kind == 0) {
        static const double exp[3][32] = {
            {
                1.000000000000000000000000000000000000000,
                0.9991161986946362635440596569713669685880,
                0.9982331784940198897326533185472850242681,
                0.9973509387078094832208641647995024627420,
                0.9964694786462737732901278365428682898391,
                0.9955887976202910746192912304685682364684,
                0.9947088949413487485322425364041275159470,
                0.9938297699215426647216913224142898699467,
                0.9929514218735766634486778457089421310313,
                0.9920738501107620182173911392473163552182,
                0.9911970539470168989248757955220583150316,
                0.9903210326968658354852077402726923030103,
                0.9894457856754391819277196598158280316812,
                0.9885713121984725809688571162894359262234,
                0.9876976115823064290572467553909520317038,
                0.9868246831438853418915583811441525830737,
                0.9859525262007576204107430418579502424629,
                0.9850811400710747172562296407417980684195,
                0.9842105240735907037056629536175321639825,
                0.9833406775276617370777663048165281180240,
                0.9824715997532455286079125206742780153835,
                0.9816032900709008117939871480322018994711,
                0.9807357478017868112121282928289778252539,
                0.9798689722676627118019278012111954856228,
                0.9790029627908871286206788726159970207714,
                0.9781377186944175770662555609768519653065,
                0.9772732393018099435682099865780080346346,
                0.9764095239372179567466734471337520306711,
                0.9755465719253926590386479823956917338692,
                0.9746843825916818787912753119951161678163,
                0.9738229552620297028216704313083937453701,
                0.9729622892629759494429075148916109501561,
            },
            {
                1.000000000000000000000000000000000000000,
                0.9721023839216556419557461414665235406759,
                0.9449830448261659815506003316741838244400,
                0.9186202706410607262354282576433721865857,
                0.8929929550089316248724185119772265808860,
                0.8680805803894262140332557150199116840610,
                0.8438632016326556552525292339254629390907,
                0.8203214300108653339129866284361494061943,
                0.7974364176955837811756247839373545193403,
                0.7751898426678221357270891859654278174299,
                0.7535638940492430676420382969418743828861,
                0.7325412578425551199256826085929390870521,
                0.7121051030697160541445567434958450232311,
                0.6922390682968472772769625589791250165011,
                0.6729272485350710325059754287002821864844,
                0.6541541825067830050114340006988959714053,
                0.6359048402671655658518413475133857442506,
                0.6181646111710312869993190871292294307424,
                0.6009192921753628362027560473439879450541,
                0.5841550764681841229558144388281781547134,
                0.5678585424146588316121044339920926624110,
                0.5520166428115664537913591359859590337117,
                0.5366166944415528229941896994764026030425,
                0.5216463679187921574527288412861688503326,
                0.5070936778179309248395866416383933681722,
                0.4929469730784106413269415008349571859159,
                0.4791949276764871892092025854239549577609,
                0.4658265315574785583888478629564160135480,
                0.4528310818209812590638301874088128310074,
                0.4401981741519981827475211630454194703175,
                0.4279176944911175684463420329167665844223,
                0.4159798109370741180402885145593642305967,
            },
            {
                1.000000000000000000000000000000000000000,
                0.4043749658752093528844267111687024946352,
                0.1635191130265767286466168121241953230561,
                0.06612303575006646581251581957553699053968,
                0.02673850032499837519017926564442803281999,
                0.01081238015647549215912747014396255582252,
                0.004372255856804567905094277088171797889884,
                0.001768030812893031377541692153909093867261,
                0.0007149473996299382156691604651236075335476,
                0.0002891068303279259298899010575129069771848,
                0.0001169075646481449883075929977115181069539,
                4.727449246514746096480558381507760086106E-5,
                1.911662127736184620584353997559933697984E-5,
                7.730283076682497589319888445443844075884E-6,
                3.125932955339193327950538126733860718160E-6,
                1.264049032143478624120751312511989786231E-6,
                5.111497842376105790435567936679525625580E-7,
                2.066961765582044014739815034159084709228E-7,
                8.358275934226015223807850299656474431551E-8,
                3.379877545678228479840194532767858969538E-8,
                1.366737867196019982379028600007217696759E-8,
                5.526745784077469928250904895328215282900E-9,
                2.234877637837284060764188149247765384222E-9,
                9.037285685357202289540219994637413662239E-10,
                3.654452090620836644843916087377680577752E-10,
                1.477768939437388295908878759559360151466E-10,
                5.975727644564382090472646695947245344300E-11,
                2.416434662350267172894275660335977107355E-11,
                9.771456841275623229028471594408844775750E-12,
                3.951332526741911117382517682123044657845E-12,
                1.597819955662865055885641210966604195704E-12,
                6.461183900458995781949987131389237968733E-13,
            },
        };

        // Compute the actual Bernoulli parameter c = exp(-t/f):
        double c = 4611686018427387904.0; // This yields a fraction of 2^62, to keep only 62 bits of precision in this implementation

        int64_t i, s;
        for ( i = 0, s = t; i < 3; i++, s >>= 5) {
            c *= exp[i][s & 31];
        }
        // Sample from Bernoulli_c
        return (uint32_t)((uint64_t)((r & 0x3FFFFFFFFFFFFFFFLL) - round_double(c)) >> 63);
    }
    if(p->kind == 1) {
        static const double exp[3][32] = {
            {
                1.000000000000000000000000000000000000000,
                0.9930872609369466438446685776045870783769,
                0.9862223078352471514816645800946617163753,
                0.9794048103630198064987096277024276745233,
                0.9726344404718809949964892248205218503718,
                0.9659108723811599790550031774166135553877,
                0.9592337825622227893519943162404944070569,
                0.9526028497229044826212304268593937992247,
                0.9460177547920490148527778717375614297184,
                0.9394781809041559863157234389191387682224,
                0.9329838133841335196263226397557142740444,
                0.9265343397321565371915254554479065418152,
                0.9201294496086297094295001392864839167637,
                0.9137688348192543502053861599866811078566,
                0.9074521893001985409223010760173581553575,
                0.9011792091033697696748437406081452352264,
                0.8949495923817893768052167676933918240273,
                0.8887630393750681031008720036903279549798,
                0.8826192523949820417374995711487459848121,
                0.8765179358111482999024679709014128311544,
                0.8704587960367996808317122241155297845427,
                0.8644415415146577017577899722859465798926,
                0.8584658827029032679986111034824856707621,
                0.8525315320612443281154225239327537518954,
                0.8466382040370798397352222582144291697216,
                0.8407856150517593802671106888137768620013,
                0.8349734834869377413443844341919836129518,
                0.8292015296710238503946615698754495016414,
                0.8234694758657233672792155446698925939247,
                0.8177770462526743084502076388248436931084,
                0.8121239669201750555508610480023292486879,
                0.8065099658500041098290290520491383950857,
            },
            {
                1.000000000000000000000000000000000000000,
                0.8009347729043309581492891476788353792319,
                0.6414965104473122043734993727836560472824,
                0.5137968619140387723649494445724253935375,
                0.4115177729160785361721013764372879501486,
                0.3295988939966353993797546624907733779656,
                0.2639872153127138259822760194764351771638,
                0.2114365403461351682772711099029673784632,
                0.1693468774258091812043290184144321199053,
                0.1356358028130980473854681895334247066416,
                0.1086354309238052987136421660339381364741,
                0.08700989419632212963388864322350046226584,
                0.06968924984856112912390130844621296957238,
                0.05581654350133048857116894376531772850611,
                0.04470541059354284482553748295802110496277,
                0.03580611788133410988908922580970256346882,
                0.02867836489387203925107389509582024748183,
                0.02296949967354093915736415916088875712606,
                0.01839707100475361618465239672776920511300,
                0.01473485388729718934389942060072706417326,
                0.01180165685200087257748615707785816032450,
                0.009452357350652160270369000159777795264839,
                0.007570721688055171417140197893346564436337,
                0.006063654255944361840448638204382454042975,
                0.004856591544455177358529410131498186861861,
                0.003889813045747301426610201899960753418453,
                0.003115486528435918796419578590889832746504,
                0.002495301495139325055182486610241845985297,
                0.001998573736337252813277171935604760180550,
                0.001600727201645837799022382894438631230426,
                0.001282078077731994286308984939556462536997,
                0.001026860914033896017267762777785748817307,
            },
            {
                1.000000000000000000000000000000000000000,
                0.0008224486129860722211363916637848860326918,
                6.764217210027140041831031984333572710182E-7,
                5.563221062323340498274022484847072751687E-10,
                4.575463446442734637606790950284979597994E-13,
                3.763083565295300843546185184301854315545E-16,
                3.094942858827803718449578214814971509997E-19,
                2.545431461514076294341840669798321223682E-22,
                2.093486574973362721749187178812187137854E-25,
                1.721785129891805064378362119288044621215E-28,
                1.416079791939559272724577415918469648772E-31,
                1.164652860758296257488258742700152576162E-34,
                9.578671299409218577167988854386920292388E-38,
                7.877964924448609922540282389759450919100E-41,
                6.479221325265686467208309495512157540942E-44,
                5.328826592194544529621668305843636827587E-47,
                4.382686039593701056175477296603487664723E-50,
                3.604534054417261435200071909889027197334E-53,
                2.964544033516540037422419325585053196748E-56,
                2.438185128501814352606789000040829068102E-59,
                2.005281977139585478986634802357029989886E-62,
                1.649241380744420660650718985253047314575E-65,
                1.356416286072483410597007136332173243839E-68,
                1.115582693112033332431603568345878366580E-71,
                9.175094386212588788144072292603516054032E-75,
                7.546043651956841286284539906283246167227E-78,
                6.206233135084259224486265414976130044209E-81,
                5.104307833818251594629732382370662953839E-84,
                4.198030898177763847327057349990235798892E-87,
                3.452664689478976857663267096113988698397E-90,
                2.839639284967972258959000310917203801857E-93,
                2.335457391302670665789857816505217149076E-96,
            },
        };

        // Compute the actual Bernoulli parameter c = exp(-t/f):
        double c = 4611686018427387904.0; // This yields a fraction of 2^62, to keep only 62 bits of precision in this implementation

        int64_t i, s;
        for ( i = 0, s = t; i < 3; i++, s >>= 5) {
            c *= exp[i][s & 31];
        }
        // Sample from Bernoulli_c
        return (uint32_t)((uint64_t)((r & 0x3FFFFFFFFFFFFFFFLL) - round_double(c)) >> 63);
    }
    if(p->kind == 2) {
        static const double exp[3][32] = {
            {
                1.000000000000000000000000000000000000000,
                0.9951980443443537316500388424172839303752,
                0.9904191474668262564830185894967173613892,
                0.9856631986401875746675941557587114196642,
                0.9809300876689149347041557365309129923940,
                0.9762197048866395987965541168345276706016,
                0.9715319411536058687432894158212596709598,
                0.9668666878541423134736924881553750396380,
                0.9622238368941451396373408016639000521875,
                0.9576032806985736469363056351479270970296,
                0.9530049122089577101698314104664824876542,
                0.9484286248809172302397073765744987564880,
                0.9438743126816934966419131566675496907225,
                0.9393418700876924042461092785035073150884,
                0.9348311920820394674392081270253399758265,
                0.9303421741521465749826061515830447550861,
                0.9258747122872904292046909607697858626672,
                0.9214287029762026134209634491584644007645,
                0.9170040432046712317435415947941667461407,
                0.9126006304531540657099452867877830194818,
                0.9082183626944031924279067014123113094560,
                0.9038571383911010091985145255388756529519,
                0.8995168564935076098442888811876009946339,
                0.8951974164371194582318032579854959087286,
                0.8908987181403393047402262055905414183192,
                0.8866206620021572916876550405654798379036,
                0.8823631488998431939863624175501337704454,
                0.8781260801866497415560803096876886684788,
                0.8739093576895269702812107160640808580937,
                0.8697128837068475485533842136704059167642,
                0.8655365610061430266950922187780245940470,
                0.8613802928218509568132024098758678171240,
            },
            {
                1.000000000000000000000000000000000000000,
                0.8572439828530728308830350554160731167033,
                0.7348672461377994256921043490917256989374,
                0.6299605249474365823836053036391959460526,
                0.5400298694461530849364654156443919196999,
                0.4629373561436452146023454803849830673216,
                0.3968502629920498686879264098181800898090,
                0.3401975000435942410639200938313063115835,
                0.2916322598940291452234231586652679613355,
                0.2500000000000000000000000000000973522517,
                0.2143109957132682077207587638541017338078,
                0.1837168115344498564230260872730029657154,
                0.1574901312368591455959013259098603145887,
                0.1350074673615382712341163539111505530487,
                0.1157343390359113036505863700962908348244,
                0.09921256574801246717198160245458365671892,
                0.08504937501089856026598002345785969688852,
                0.07290806497350728630585578966634538139103,
                0.06250000000000000000000000000004867612583,
                0.05357774892831705193018969096354629710993,
                0.04592920288361246410575652181826862667413,
                0.03937253280921478639897533147748041066606,
                0.03375186684038456780852908847780078154311,
                0.02893358475897782591264659252408397570460,
                0.02480314143700311679299540061365557274640,
                0.02126234375272464006649500586447320397029,
                0.01822701624337682157646394741659344311205,
                0.01562500000000000000000000000001825354719,
                0.01339443723207926298254742274089179019198,
                0.01148230072090311602643913045457162797985,
                0.009843133202303696599743832869373935671238,
                0.008437966710096141952132272119453481206014,
            },
            {
                1.000000000000000000000000000000000000000,
                0.007233396189744456478161648131023810675775,
                5.232202043780962102557587008169005410143E-5,
                3.784659032745836912993682954976324658164E-7,
                2.737593822694567686662466634421542264066E-9,
                1.980210072614684707158711353745069372717E-11,
                1.432364399414465384287735340977513952565E-13,
                1.036085918905020069841154248521752033776E-15,
                7.494419938055456100418425186702743722723E-18,
                5.421010862427522170037264004417260251684E-20,
                3.921231931684654880817938739668273317360E-22,
                2.836382411375207747860568187463889509638E-24,
                2.051667772709962123314993704273413823620E-26,
                1.484052584974173558955043468582713624191E-28,
                1.073474031353259824558654154333806911547E-30,
                7.764862968180290824468612020607860317513E-33,
                5.616633020792314645332222710264644852793E-35,
                4.062733189179202535382045195211707654781E-37,
                2.938735877055718769921841343128853888538E-39,
                2.125704089576016965228859756656407540404E-41,
                1.537605986206336992222535387300608525931E-43,
                1.112211328195318530448364746285024038827E-45,
                8.045065183558638234146057828832053516826E-48,
                5.819314384499884015403474144560288801662E-50,
                4.209340649576656799996170991423257963815E-52,
                3.044782861598424467581974062513986546956E-54,
                2.202412074968526631812431321732133496007E-56,
                1.593091911132452277028880397827266782094E-58,
                1.152346495989819456843455045622426762614E-60,
                8.335378753358135655955994470664225877261E-63,
                6.029309691461763611680553229574282672923E-65,
                4.361238574900884540660050746922306538111E-67,
            },
        };

        // Compute the actual Bernoulli parameter c = exp(-t/f):
        double c = 4611686018427387904.0; // This yields a fraction of 2^62, to keep only 62 bits of precision in this implementation

        int64_t i, s;
        for ( i = 0, s = t; i < 3; i++, s >>= 5) {
            c *= exp[i][s & 31];
        }
        // Sample from Bernoulli_c
        return (uint32_t)((uint64_t)((r & 0x3FFFFFFFFFFFFFFFLL) - round_double(c)) >> 63);
    }
    if(p->kind == 3) {
        static const double exp[3][32] = {
            {
                1.000000000000000000000000000000000000000,
                0.9930924954370359015332102168880765048173,
                0.9862327044933591729073804985266878802443,
                0.9794202975869268710835182321094224250961,
                0.9726549474122855185227020947295413763023,
                0.9659363289248455510651443129204733029988,
                0.9592641193252643901322834293949397264660,
                0.9526379980439373889289005948680289570903,
                0.9460576467255959075051119972754354254470,
                0.9395227492140117766851490088262829075331,
                0.9330329915368074159813432661499603336007,
                0.9265880618903708756879317851202732375877,
                0.9201876506248750783904312382017973974891,
                0.9138314502294005401326428921359892449876,
                0.9075191553171608564550809482180658363403,
                0.9012504626108302434560060155923701020040,
                0.8950250709279724289295293992056807493013,
                0.8888426811665701935046683790031660959701,
                0.8827029962906548665450116490541232503509,
                0.8766057213160350863710299119436526437378,
                0.8705505632961241391362700174797799990040,
                0.8645372313078651954249311342751209858410,
                0.8585654364377537683418658040230197384022,
                0.8526348917679567215371033354114150564474,
                0.8467453123625271602457822707284519309456,
                0.8408964152537145430311254762332558266219,
                0.8350879194283693564930171007187976000468,
                0.8293195458144416997480650199452263126561,
                0.8235910172675731299989737240342361894393,
                0.8179020585577811249918276889374069238047,
                0.8122523963562355226097093827753290960475,
                0.8066417592221263022701629871861700330324,
            },
            {
                1.000000000000000000000000000000000000000,
                0.8010698775896220771825769800356152059027,
                0.6417129487814520990379170897814202226189,
                0.5140569133280332546731724793964135739076,
                0.4117955086337865649994868620171982731639,
                0.3298769776932235648435004928075127989168,
                0.2642545101403450936248735535216273644409,
                0.2116863280906317900614455676821954153035,
                0.1695755409309589853967628341412449203495,
                0.1358418578157572626069007404662307881780,
                0.1088188204120155173920337521850360624220,
                0.08717147914690033876721823536549963755605,
                0.06983044612951374791318691470020735054081,
                0.05593906693299827680809558745039861318662,
                0.04481110150049460568456273455878078046507,
                0.03589682359365734396245709208684378568331,
                0.02875586408202734619970097619383416315419,
                0.02303545652017345644205569949585157876541,
                0.01845301033483641249297602669511968917867,
                0.01478215073008743605476737495744594743142,
                0.01184153567586248501833796719772135927005,
                0.009485897534336303604787967133085469399049,
                0.007598866776658480613458610115084898737984,
                0.006087223278597655149117219956228990612855,
                0.004876291206646921576592633968279399063782,
                0.003906250000000000000000000000006084516053,
                0.003129179209334461238994441328268996020587,
                0.002506691206177547261866863631962577257343,
                0.002008034817687629901067079997645368310618,
                0.001608576205600728769529245554757186330929,
                0.001288581944114154550169923800031354012535,
                0.001032244180235723021972162318445464753156,
            },
            {
                1.000000000000000000000000000000000000000,
                0.0008268997191040304299275217487598638498908,
                6.837631454543244275598561791827450446268E-7,
                5.654035529098691704742888887601969318770E-10,
                4.675320390815916240837145591289455678271E-13,
                3.866021117887026910581260785663924052584E-16,
                3.196811776431032265107748321378670183434E-19,
                2.643442759959277106397015416454182808165E-22,
                2.185862075677909177530183421677021601630E-25,
                1.807488736378216004902267757945329990433E-28,
                1.494611928394845722509566662381681852231E-31,
                1.235894183759231170477230799378805483584E-34,
                1.021960553392813221805059629881904702629E-37,
                8.450588945359167454685108853553438401193E-41,
                6.987789625181120323479538530531788834637E-44,
                5.778201278220326478541087516212630539830E-47,
                4.777993013886937548374901071454718579294E-50,
                3.950921081064128423947108109095179681258E-53,
                3.267015532134120033414586853048549151733E-56,
                2.701494225830208356330596231491229575841E-59,
                2.233864816500159437321055999997722887780E-62,
                1.847182189280358319436455385107649366142E-65,
                1.527434433449896263866613728025637317872E-68,
                1.263035103969543081968346060350962609985E-71,
                1.044403372690945043917523022329044283453E-74,
                8.636168555094444625386351863230863826745E-78,
                7.141245352342656606906053992842560076147E-81,
                5.905093775905105564186232605424573035226E-84,
                4.882920384578890205960673105845289217904E-87,
                4.037685494415628551550334502904113261957E-90,
                3.338761001162701476381524668052565130775E-93,
                2.760820534016929266476966660680800456743E-96,
            },
        };

        // Compute the actual Bernoulli parameter c = exp(-t/f):
        double c = 4611686018427387904.0; // This yields a fraction of 2^62, to keep only 62 bits of precision in this implementation

        int64_t i, s;
        for (i = 0, s = t; i < 3; i++, s >>= 5) {
            c *= exp[i][s & 31];
        }
        // Sample from Bernoulli_c
        return (uint32_t)((uint64_t)((r & 0x3FFFFFFFFFFFFFFFLL) - round_double(c)) >> 63);
    }
    if(p->kind == 4) {
        static const double exp[3][32] = {
            {
                1.000000000000000000000000000000000000000,
                0.9930924954370359015332102168880765048173,
                0.9862327044933591729073804985266878802443,
                0.9794202975869268710835182321094224250961,
                0.9726549474122855185227020947295413763023,
                0.9659363289248455510651443129204733029988,
                0.9592641193252643901322834293949397264660,
                0.9526379980439373889289005948680289570903,
                0.9460576467255959075051119972754354254470,
                0.9395227492140117766851490088262829075331,
                0.9330329915368074159813432661499603336007,
                0.9265880618903708756879317851202732375877,
                0.9201876506248750783904312382017973974891,
                0.9138314502294005401326428921359892449876,
                0.9075191553171608564550809482180658363403,
                0.9012504626108302434560060155923701020040,
                0.8950250709279724289295293992056807493013,
                0.8888426811665701935046683790031660959701,
                0.8827029962906548665450116490541232503509,
                0.8766057213160350863710299119436526437378,
                0.8705505632961241391362700174797799990040,
                0.8645372313078651954249311342751209858410,
                0.8585654364377537683418658040230197384022,
                0.8526348917679567215371033354114150564474,
                0.8467453123625271602457822707284519309456,
                0.8408964152537145430311254762332558266219,
                0.8350879194283693564930171007187976000468,
                0.8293195458144416997480650199452263126561,
                0.8235910172675731299989737240342361894393,
                0.8179020585577811249918276889374069238047,
                0.8122523963562355226097093827753290960475,
                0.8066417592221263022701629871861700330324,
            },
            {
                1.000000000000000000000000000000000000000,
                0.8010698775896220771825769800356152059027,
                0.6417129487814520990379170897814202226189,
                0.5140569133280332546731724793964135739076,
                0.4117955086337865649994868620171982731639,
                0.3298769776932235648435004928075127989168,
                0.2642545101403450936248735535216273644409,
                0.2116863280906317900614455676821954153035,
                0.1695755409309589853967628341412449203495,
                0.1358418578157572626069007404662307881780,
                0.1088188204120155173920337521850360624220,
                0.08717147914690033876721823536549963755605,
                0.06983044612951374791318691470020735054081,
                0.05593906693299827680809558745039861318662,
                0.04481110150049460568456273455878078046507,
                0.03589682359365734396245709208684378568331,
                0.02875586408202734619970097619383416315419,
                0.02303545652017345644205569949585157876541,
                0.01845301033483641249297602669511968917867,
                0.01478215073008743605476737495744594743142,
                0.01184153567586248501833796719772135927005,
                0.009485897534336303604787967133085469399049,
                0.007598866776658480613458610115084898737984,
                0.006087223278597655149117219956228990612855,
                0.004876291206646921576592633968279399063782,
                0.003906250000000000000000000000006084516053,
                0.003129179209334461238994441328268996020587,
                0.002506691206177547261866863631962577257343,
                0.002008034817687629901067079997645368310618,
                0.001608576205600728769529245554757186330929,
                0.001288581944114154550169923800031354012535,
                0.001032244180235723021972162318445464753156,
            },
            {
                1.000000000000000000000000000000000000000,
                0.0008268997191040304299275217487598638498908,
                6.837631454543244275598561791827450446268E-7,
                5.654035529098691704742888887601969318770E-10,
                4.675320390815916240837145591289455678271E-13,
                3.866021117887026910581260785663924052584E-16,
                3.196811776431032265107748321378670183434E-19,
                2.643442759959277106397015416454182808165E-22,
                2.185862075677909177530183421677021601630E-25,
                1.807488736378216004902267757945329990433E-28,
                1.494611928394845722509566662381681852231E-31,
                1.235894183759231170477230799378805483584E-34,
                1.021960553392813221805059629881904702629E-37,
                8.450588945359167454685108853553438401193E-41,
                6.987789625181120323479538530531788834637E-44,
                5.778201278220326478541087516212630539830E-47,
                4.777993013886937548374901071454718579294E-50,
                3.950921081064128423947108109095179681258E-53,
                3.267015532134120033414586853048549151733E-56,
                2.701494225830208356330596231491229575841E-59,
                2.233864816500159437321055999997722887780E-62,
                1.847182189280358319436455385107649366142E-65,
                1.527434433449896263866613728025637317872E-68,
                1.263035103969543081968346060350962609985E-71,
                1.044403372690945043917523022329044283453E-74,
                8.636168555094444625386351863230863826745E-78,
                7.141245352342656606906053992842560076147E-81,
                5.905093775905105564186232605424573035226E-84,
                4.882920384578890205960673105845289217904E-87,
                4.037685494415628551550334502904113261957E-90,
                3.338761001162701476381524668052565130775E-93,
                2.760820534016929266476966660680800456743E-96,
            },
        };

        // Compute the actual Bernoulli parameter c = exp(-t/f):
        double c = 4611686018427387904.0; // This yields a fraction of 2^62, to keep only 62 bits of precision in this implementation

        int64_t i, s;
        for ( i = 0, s = t; i < 3; i++, s >>= 5) {
            c *= exp[i][s & 31];
        }
        // Sample from Bernoulli_c
        return (uint32_t)((uint64_t)((r & 0x3FFFFFFFFFFFFFFFLL) - round_double(c)) >> 63);
    }
    return 0;
}

void sample_gauss_poly(int64_t *x, const unsigned char *seed, int nonce, tesla_param_t *p) { // Gaussian sampler

    unsigned char *seed_ex = malloc(p->PARAM_N * 8 * sizeof(unsigned char));
    int64_t i, j = 0, x_ind;
    int64_t *buf = (int64_t *) seed_ex;
    int64_t sign, k, bitsremained, rbits, y, z;
    uint64_t r, s, t, c;
    int16_t dmsp = (int16_t)(nonce << 8);

    if((p->kind) == 0 || (p->kind) == 3) {
        static const int64_t cdt[12][2] = {
            {0x0200000000000000LL, 0x0000000000000000LL},
            {0x0300000000000000LL, 0x0000000000000000LL},
            {0x0320000000000000LL, 0x0000000000000000LL},
            {0x0321000000000000LL, 0x0000000000000000LL},
            {0x0321020000000000LL, 0x0000000000000000LL},
            {0x0321020100000000LL, 0x0000000000000000LL},
            {0x0321020100200000LL, 0x0000000000000000LL},
            {0x0321020100200100LL, 0x0000000000000000LL},
            {0x0321020100200100LL, 0x0200000000000000LL},
            {0x0321020100200100LL, 0x0200010000000000LL},
            {0x0321020100200100LL, 0x0200010000200000LL},
            {0x0321020100200100LL, 0x0200010000200001LL},
        };

        cshake128_simple(seed_ex, (p->PARAM_N) * 8, dmsp++, seed, CRYPTO_RANDOMBYTES);
//        cSHAKE128( seed, CRYPTO_RANDOMBYTES * 8, seed_ex, (p->PARAM_N) * 8 * 8, NULL, 0, &dmsp, 16 );
//        ++dmsp;

        for (x_ind = 0; x_ind < (int64_t)(p->PARAM_N); x_ind++) {
            if ((j + 46) > (int64_t)(p->PARAM_N)) {
              cshake128_simple((uint8_t *) buf, (p->PARAM_N) * 8, dmsp++, seed, CRYPTO_RANDOMBYTES);
//                cSHAKE128( seed, CRYPTO_RANDOMBYTES * 8, (uint8_t *) buf, (p->PARAM_N) * 8 * 8, NULL, 0, &dmsp, 16 );
//                ++dmsp;
                j = 0;
            }
            do {
                rbits = buf[j++];
                bitsremained = 64;
                do {
                    // Sample x from D^+_{\sigma_2} and y from U({0, ..., k-1}):
                    do {
                        r = buf[j++];
                        s = buf[j++];
                        if (bitsremained <= 64 - 6) {
                            rbits = (rbits << 6) ^ ((r >> 58) & 63);
                            bitsremained += 6;
                        }
                        r &= 0x03FFFFFFFFFFFFFFLL;
                    } while (r > 0x0321020100200100LL);
                    y = 0;
                    for (i = 0; i < 12; i++) {
                        c = s - cdt[i][1];
                        uint64_t b = (((c & cdt[i][1]) & 1) + (cdt[i][1] >> 1) + (c >> 1)) >> 63;
                        c = r - (cdt[i][0] + b);
                        y += ~(c >> (63)) & 1LL;
                    }

                    // The next sampler works exclusively for PARAM_Xi <= 28
                    do {
                        do {
                            if (bitsremained < 6) {
                                rbits = buf[j++];
                                bitsremained = 64;
                            }
                            z = rbits & 63;
                            rbits >>= 6;
                            bitsremained -= 6;
                        } while (z == 63);
                        if (bitsremained < 2) {
                            rbits = buf[j++];
                            bitsremained = 64;
                        }
                        z = (mod7(z) << 2) + (rbits & 3);
                        rbits >>= 2;
                        bitsremained -= 2;
                    } while (z >= p->PARAM_Xi); // Making sure random z does not exceed a certain limit. No private data leaked, it varies uniformly
                    k = (int64_t)(p->PARAM_Xi * y) + z;
                    // Sample a bit from Bernoulli_{exp(-y*(y + 2*k*x)/(2*k^2*sigma_2^2))}
                } while (Bernoulli(buf[j++], z * ((k << 1) - z), p) == 0);

                // Put last randombits into sign bit
                rbits <<= (64 - bitsremained);
                if (bitsremained == 0LL) {
                    rbits = buf[j++];
                    bitsremained = 64;
                }
                sign = rbits >> 63;
                rbits <<= 1;
                bitsremained--;
            } while ((k | (sign & 1)) == 0);
            if (bitsremained == 0LL) {
                rbits = buf[j++];
                bitsremained = 64;
            }
            sign = rbits >> 63;
            rbits <<= 1;
            bitsremained--;
            k = ((k << 1) & sign) - k;
            x[x_ind] = (k << 48) >> 48;
        }
    }
    else {
        static const int64_t cdt[14][3] = {
            {0x0000020000000000LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000030000000000LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000032000000000LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000032100000000LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000032102000000LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000032102010000LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000032102010020LL, 0x0000000000000000LL, 0x0000000000000000LL},
            {0x0000032102010020LL, 0x0100000000000000LL, 0x0000000000000000LL},
            {0x0000032102010020LL, 0x0100020000000000LL, 0x0000000000000000LL},
            {0x0000032102010020LL, 0x0100020001000000LL, 0x0000000000000000LL},
            {0x0000032102010020LL, 0x0100020001000020LL, 0x0000000000000000LL},
            {0x0000032102010020LL, 0x0100020001000020LL, 0x0001000000000000LL},
            {0x0000032102010020LL, 0x0100020001000020LL, 0x0001000002000000LL},
            {0x0000032102010020LL, 0x0100020001000020LL, 0x0001000002000001LL},
        };        

      cshake256_simple(seed_ex, (p->PARAM_N) * 8, dmsp++, seed, CRYPTO_RANDOMBYTES);
//        cSHAKE256( seed, CRYPTO_RANDOMBYTES * 8, seed_ex, (p->PARAM_N) * 8 * 8, NULL, 0, &dmsp, 16 );
//        ++dmsp;

        for (x_ind = 0; x_ind < (int64_t)(p->PARAM_N); x_ind++) {
            if ((j + 46) > (int64_t)(p->PARAM_N)) {
              cshake256_simple((uint8_t *) buf, (p->PARAM_N) * 8, dmsp++, seed, CRYPTO_RANDOMBYTES);
//                cSHAKE256( seed, CRYPTO_RANDOMBYTES * 8, (uint8_t *) buf, (p->PARAM_N) * 8 * 8, NULL, 0, &dmsp, 16 );
//                ++dmsp;

                j = 0;
            }
            do {
                rbits = buf[j++];
                bitsremained = 64;
                do {
                    // Sample x from D^+_{\sigma_2} and y from U({0, ..., k-1}):
                    do {
                        r = buf[j++];
                        s = buf[j++];
                        t = buf[j++];
                        if (bitsremained <= 64 - 6) {
                            rbits = (rbits << 6) ^ ((r >> 58) & 63);
                            bitsremained += 6;
                        }
                        r &= 0x000003FFFFFFFFFFLL;
                    } while (r > 0x0000032102010020LL);
                    y = 0;
                    for (i = 0; i < 14; i++) {
                        c = t - cdt[i][2];
                        uint64_t b = (((c & cdt[i][2]) & 1) + (cdt[i][2] >> 1) + (c >> 1)) >> 63;
                        // Least significant bits of all cdt[i][1] are zero: overflow cannot occur at this point
                        c = s - (cdt[i][1] + b);
                        b = (((c & b) & 1) + ((cdt[i][1]) >> 1) + (c >> 1)) >> 63;
                        // Least significant bits of all cdt[i][0] are zero: overflow cannot occur at this point
                        c = r - (cdt[i][0] + b);
                        y += ~(c >> (63)) & 1LL;
                    }

                    // The next sampler works exclusively for PARAM_Xi <= 28
                    do {
                        do {
                            if (bitsremained < 6) {
                                rbits = buf[j++];
                                bitsremained = 64;
                            }
                            z = rbits & 63;
                            rbits >>= 6;
                            bitsremained -= 6;
                        } while (z == 63);
                        if (bitsremained < 2) {
                            rbits = buf[j++];
                            bitsremained = 64;
                        }
                        z = (mod7(z) << 2) + (rbits & 3);
                        rbits >>= 2;
                        bitsremained -= 2;
                    } while (z >= p->PARAM_Xi); // Making sure random z does not exceed a certain limit. No private data leaked, it varies uniformly
                    k = (int64_t)(p->PARAM_Xi * y) + z;
                    // Sample a bit from Bernoulli_{exp(-y*(y + 2*k*x)/(2*k^2*sigma_2^2))}
                } while (Bernoulli(buf[j++], z * ((k << 1) - z), p) == 0);

                // Put last randombits into sign bit
                rbits <<= (64 - bitsremained);
                if (bitsremained == 0LL) {
                    rbits = buf[j++];
                    bitsremained = 64;
                }
                sign = rbits >> 63;
                rbits <<= 1;
                bitsremained--;
            } while ((k | (sign & 1)) == 0);
            if (bitsremained == 0LL) {
                rbits = buf[j++];
                bitsremained = 64;
            }
            sign = rbits >> 63;
            rbits <<= 1;
            bitsremained--;
            k = ((k << 1) & sign) - k;
            x[x_ind] = (k << 48) >> 48;
        }
    }
    free(seed_ex);
    seed_ex = NULL;
}

void encode_c(uint32_t *pos_list, int16_t *sign_list, unsigned char *c_bin, tesla_param_t *p) { // Encoding of c' by mapping the output of the hash function H to an N-element vector with entries {-1,0,1}

    uint32_t i;
    int pos, cnt = 0;
    int16_t *c = malloc(p->PARAM_N * sizeof(int16_t));
    const int RLENGTH = SHAKE128_RATE;
    unsigned char *r = malloc(RLENGTH * sizeof(unsigned char));
    uint16_t dmsp = 0;

    // Use the hash value as key to generate some randomness
  cshake128_simple(r, RLENGTH, dmsp++, c_bin, CRYPTO_RANDOMBYTES);
//    cSHAKE128( c_bin, CRYPTO_RANDOMBYTES * 8, r, RLENGTH * 8, NULL, 0, &dmsp, 16 );
//    ++dmsp;

    // Use rejection sampling to determine positions to be set in the new vector
    for (i = 0; i < p->PARAM_N; i++)
        c[i] = 0;

    for (i = 0; i < p->PARAM_W;) { // Sample a unique position k times. Use two bytes
        if (cnt > (RLENGTH - 3)) {
          cshake128_simple(r, RLENGTH, dmsp++, c_bin, CRYPTO_RANDOMBYTES);
//            cSHAKE128( c_bin, CRYPTO_RANDOMBYTES * 8, r, RLENGTH * 8, NULL, 0, &dmsp, 16 );
//            ++dmsp;
            cnt = 0;
        }
        pos = (r[cnt] << 8) | (r[cnt + 1]);
        pos = pos & ((p->PARAM_N) - 1); // Position is in the range [0,N-1]

        if (c[pos] == 0) { // Position has not been set yet. Determine sign
            if ((r[cnt + 2] & 1) == 1)
                c[pos] = -1;
            else
                c[pos] = 1;
            pos_list[i] = pos;
            sign_list[i] = c[pos];
            i++;
        }
        cnt += 3;
    }
    free(c);
    free(r);
    c = NULL;
    r = NULL;
}
