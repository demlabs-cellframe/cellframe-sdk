/*
 * Authors:
 * Dmitriy A. Gearasimov <gerasimov.dmitriy@demlabs.net>
 * Alexander Lysikov <alexander.lysikov@demlabs.net>
 * DeM Labs Inc.   https://demlabs.net
 * Kelvin Project https://github.com/kelvinblockchain
 * Copyright  (c) 2017-2019
 * All rights reserved.

 This file is part of DAP (Distributed Applications Platform) the open source project

 DAP (Distributed Applications Platform) is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 DAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with any DAP based project.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stddef.h>
#include <assert.h>
#include <memory.h>

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#include <io.h>
#include <time.h>
#include <pthread.h>
#endif

#include "dap_common.h"
#include "dap_hash.h"
#include "dap_http_client.h"
#include "dap_http_simple.h"
#include "dap_enc_base58.h"
#include "dap_enc_http.h"
#include "dap_http_status_code.h"
#include "dap_chain_common.h"
// REMOVED: dap_chain_node.h - dead include, not used
#include "dap_global_db.h"
#include "dap_global_db_cluster.h"
#include "dap_enc.h"
#include <dap_enc_http.h>
#include <dap_enc_key.h>
#include <dap_enc_ks.h>
#include "dap_chain_mempool.h"

#include "dap_common.h"
#include "dap_list.h"
#include "dap_chain.h"
#include "dap_chain_net_core.h"  // All net API through core (no direct net dependency)
#include "dap_chain_net_types.h"  // For access to net->pub fields
#include "dap_chain_net.h"  // Headers OK (no CMake link dependency = no cycle)
// REMOVED target_link_libraries dependency on dap_chain_net in CMakeLists - that creates cycle
// But headers can be included safely for declarations
#include "dap_chain_net_tx.h"  // For dap_chain_net_tx_get_fee
#include "dap_chain_wallet.h"  // For dap_chain_wallet_get_list_tx_outs_with_val
#include "dap_sign.h"
#include "dap_chain_datum_tx.h"
#include "dap_chain_datum_tx_items.h"
// REMOVED: dap_chain_block_tx.h - deprecated wrapper functions removed to break mempool <-> blocks cycle
// REMOVED: dap_chain_wallet.h - dead include, not used
#include "dap_chain_ledger.h"  // Normal dependency: mempool (high) â†’ ledger (mid)
#include "dap_chain_mempool_cli.h"

#define LOG_TAG "dap_chain_mempool"

extern int g_dap_global_db_debug_more;

static bool s_tx_create_massive_gdb_save_callback(dap_global_db_instance_t *a_dbi,
                                                  int a_rc, const char *a_group,
                                                  const size_t a_values_total, const size_t a_values_count,
                                                  dap_global_db_obj_t *a_values, void *a_arg);

/**
 * @brief Callback function for handling mempool record deletion by TTL
 * @details This callback is triggered when a mempool record expires due to TTL.
 *          It notifies all cluster subscribers about the deletion and then removes the record.
 * @param a_obj Store object being deleted (contains datum from mempool)
 * @param a_arg Custom argument (chain pointer)
 */
static void s_mempool_ttl_delete_callback(dap_store_obj_t *a_obj, void *a_arg)
{
    if (!a_obj) {
        log_it(L_WARNING, "Received NULL object in mempool TTL delete callback");
        return;
    }

    dap_chain_t *l_chain = (dap_chain_t *)a_arg;
    if (!l_chain) {
        log_it(L_WARNING, "Chain context is NULL in mempool TTL delete callback for group %s key %s", 
               a_obj->group, a_obj->key);
        dap_global_db_driver_delete(a_obj, 1);
        return;
    }

    // Get the mempool cluster to access notifiers
    dap_global_db_cluster_t *l_cluster = dap_chain_net_get_mempool_cluster(l_chain);
    if (!l_cluster) {
        log_it(L_WARNING, "Can't find mempool cluster for chain %s", l_chain->name);
        dap_global_db_driver_delete(a_obj, 1);
        return;
    }

    // Log the deletion event
    const char *l_datum_type_str = "unknown";
    if (a_obj->value && a_obj->value_len >= sizeof(dap_chain_datum_t)) {
        dap_chain_datum_t *l_datum = (dap_chain_datum_t *)a_obj->value;
        switch (l_datum->header.type_id) {
        case DAP_CHAIN_DATUM_TOKEN:
            l_datum_type_str = "token";
            break;
        case DAP_CHAIN_DATUM_TOKEN_EMISSION:
            l_datum_type_str = "emission";
            break;
        case DAP_CHAIN_DATUM_TX:
            l_datum_type_str = "transaction";
            break;
        default:
            DAP_DATUM_TYPE_STR(l_datum->header.type_id, l_datum_type_str);
        }
    }

    log_it(L_NOTICE, "Mempool TTL cleanup: removing %s datum with key %s from chain %s mempool group %s", 
           l_datum_type_str, a_obj->key, l_chain->name, a_obj->group);

    // Mark object as being deleted by TTL (set DEL flag for notifiers to recognize)
    // This allows notifiers to distinguish between normal operations and TTL deletions
    a_obj->flags |= DAP_GLOBAL_DB_RECORD_DEL;

    // IMPORTANT: Notify all cluster subscribers BEFORE actual deletion
    // This allows them to react to the deletion event (e.g., update caches, logs, etc.)
    if (l_cluster->notifiers) {
        debug_if(g_dap_global_db_debug_more, L_DEBUG, 
                 "Notifying cluster subscribers about TTL deletion of %s:%s", 
                 a_obj->group, a_obj->key);
        dap_global_db_cluster_notify(l_cluster, a_obj);
    }

    // Actually delete the record from GlobalDB
    dap_global_db_driver_delete(a_obj, 1);
}

/**
 * @brief Initialize mempool TTL delete callbacks for all chains
 * @details Registers del_callback for each chain's mempool cluster to handle TTL-based deletions
 * @return 0 if successful, negative error code otherwise
 */
int dap_chain_mempool_delete_callback_init()
{
    int l_registered_count = 0;
    
    for (dap_chain_net_t *l_net = dap_chain_net_iter_start(); l_net; l_net = dap_chain_net_iter_next(l_net)) {
        dap_chain_t *l_chain = NULL;
        
        // Iterate through all chains in the network
        DL_FOREACH(l_net->pub.chains, l_chain) {
            // Get the mempool cluster for this chain
            dap_global_db_cluster_t *l_cluster = dap_chain_net_get_mempool_cluster(l_chain);
            
            if (!l_cluster) {
                log_it(L_WARNING, "Can't find mempool cluster for chain %s in network %s", 
                       l_chain->name, l_net->pub.name);
                continue;
            }
            
            // Register the delete callback
            l_cluster->del_callback = s_mempool_ttl_delete_callback;
            l_cluster->del_arg = l_chain;
            
            log_it(L_INFO, "Registered mempool TTL delete callback for chain %s (network %s, group mask %s)", 
                   l_chain->name, l_net->pub.name, l_cluster->groups_mask);
            
            l_registered_count++;
        }
    }
    
    if (l_registered_count > 0) {
        log_it(L_NOTICE, "Mempool TTL delete callbacks initialized for %d chain(s)", l_registered_count);
        return 0;
    } else {
        log_it(L_WARNING, "No mempool TTL delete callbacks were registered");
        return -1;
    }
}

int dap_datum_mempool_init(void)
{
    dap_chain_mempool_delete_callback_init();
    
    // Register mempool CLI commands
    int l_cli_res = dap_chain_mempool_cli_init();
    if (l_cli_res != 0) {
        log_it(L_WARNING, "Failed to initialize mempool CLI commands: %d", l_cli_res);
    }
    
    return 0;
}

/**
 * @brief dap_chain_mempool_datum_add
 * @param a_datum
 * @return
 */
char *dap_chain_mempool_datum_add(const dap_chain_datum_t *a_datum, dap_chain_t *a_chain, const char *a_hash_out_type)
{
    dap_return_val_if_pass(!a_datum, NULL);

    dap_chain_hash_fast_t l_key_hash;
    dap_chain_datum_calc_hash(a_datum, &l_key_hash);
    char *l_key_str = dap_chain_hash_fast_to_str_new(&l_key_hash);
    const char *l_key_str_out = dap_strcmp(a_hash_out_type, "hex")
            ? dap_enc_base58_encode_hash_to_str_static(&l_key_hash)
            : l_key_str;

    const char *l_type_str;
    switch (a_datum->header.type_id) {
    case DAP_CHAIN_DATUM_TOKEN:
        l_type_str = "token";
        break;
    case DAP_CHAIN_DATUM_TOKEN_EMISSION: {
        size_t l_emission_size = a_datum->header.data_size;
        dap_chain_datum_token_emission_t *l_emission = dap_chain_datum_emission_read((byte_t*)a_datum->data, &l_emission_size);
        uint64_t l_net_id = l_emission ? l_emission->hdr.address.net_id.uint64 : 0;
        DAP_DELETE(l_emission);
        if (l_net_id != a_chain->net_id.uint64) {
            log_it(L_WARNING, "Datum emission with hash %s NOT placed in mempool: wallet addr net ID %lu != %lu chain net ID",
                   l_key_str_out, l_net_id, a_chain->net_id.uint64);
            DAP_DELETE(l_key_str);
            return NULL;
        }
        l_type_str = "emission";
        break;
    }
    case DAP_CHAIN_DATUM_TX:
        l_type_str = "transaction";
        break;
    default:
        DAP_DATUM_TYPE_STR(a_datum->header.type_id, l_type_str);
    }

    char *l_gdb_group = dap_chain_mempool_group_new(a_chain);
    int l_res = dap_global_db_set_sync(l_gdb_group, l_key_str, a_datum, dap_chain_datum_size(a_datum), false);//, NULL, NULL);
    if (l_res == DAP_GLOBAL_DB_RC_SUCCESS)
        log_it(L_NOTICE, "Datum %s with hash %s was placed in mempool group %s", l_type_str, l_key_str_out, l_gdb_group);
    else
        log_it(L_WARNING, "Can't place datum %s with hash %s in mempool group %s", l_type_str, l_key_str_out, l_gdb_group);
    char *ret = (l_res == DAP_GLOBAL_DB_RC_SUCCESS) ? dap_strdup(l_key_str_out) : NULL;
    DAP_DELETE(l_gdb_group);
    DAP_DELETE(l_key_str);
    return ret;
}

/**
 * Make transfer transaction & insert to cache
 *
 * return 0 Ok, -2 not enough funds to transfer, -1 other Error
 */

// NOTE: dap_chain_mempool_tx_coll_fee_create, dap_chain_mempool_tx_reward_create,
// dap_chain_mempool_tx_coll_fee_stack_create were REMOVED - they were deprecated wrappers 
// that created cyclic dependency mempool <-> blocks. Use dap_chain_block_tx_* functions 
// directly from type/blocks module instead.

/**
 * Make transfer transaction & insert to cache
 *
 * return 0 Ok, -2 not enough funds to transfer, -1 other Error
 */

/**
 * @brief s_tx_create_massive_gdb_save_callback
 * @param a_global_db_context
 * @param a_rc
 * @param a_group
 * @param a_key
 * @param a_values_total
 * @param a_values_shift
 * @param a_values_count
 * @param a_values
 * @param a_arg
 */
static bool s_tx_create_massive_gdb_save_callback(dap_global_db_instance_t *a_dbi,
                                                  int a_rc, const char *a_group,
                                                  const size_t a_values_total, const size_t a_values_count,
                                                  dap_global_db_obj_t *a_values, void *a_arg)
{
    if(!a_rc) {
        log_it(L_NOTICE, "%zu transaction are placed in mempool", a_values_total);
        return true;
    } else {
        log_it(L_ERROR, "Can't place %zu transactions  in mempool", a_values_total);
        return false;
    }
}


/**
 * Make transfer transaction & insert to cache
 *
 * return 0 Ok, -2 not enough funds to transfer, -1 other Error
 */

/**
 * Make transfer transaction
 *
 * return dap_chain_datum_t, NULL if Error
 */
    dap_ledger_t * l_ledger = a_net ? dap_ledger_by_net_name( a_net->pub.name ) : NULL;
    // check valid param
    if (!a_net || !l_ledger || !a_key_from || !a_pkey_cond_hash ||
            !a_key_from->priv_key_data || !a_key_from->priv_key_data_size || IS_ZERO_256(a_value))
        return NULL;

    if (dap_strcmp(a_net->pub.native_ticker, a_token_ticker)) {
        log_it(L_WARNING, "Pay for service should be only in native token ticker");
        return NULL;
    }

    uint256_t l_net_fee = {};
    dap_chain_addr_t l_addr_fee = {};
    bool l_net_fee_used = dap_chain_net_tx_get_fee(a_net->pub.id, &l_net_fee, &l_addr_fee);
    // find the transactions from which to take away coins
    uint256_t l_value_transfer = {}; // how many coins to transfer
    uint256_t l_value_need = {};
    SUM_256_256(a_value, a_value_fee, &l_value_need);
    if (l_net_fee_used) {
        SUM_256_256(l_value_need, l_net_fee, &l_value_need);
    }
    // where to take coins for service
    dap_chain_addr_t l_addr_from;
    dap_chain_addr_fill_from_key(&l_addr_from, a_key_from, a_net->pub.id);
    // list of transaction with 'out' items
    dap_list_t *l_list_used_out = dap_chain_wallet_get_list_tx_outs_with_val(l_ledger, a_token_ticker,
                                                                             &l_addr_from, l_value_need, &l_value_transfer);
    if(!l_list_used_out) {
        log_it( L_ERROR, "Nothing to transfer (not enough funds)");
        return NULL;
    }

    // create empty transaction
    dap_chain_datum_tx_t *l_tx = dap_chain_datum_tx_create();
    // add 'in' items
    {
        uint256_t l_value_to_items = dap_chain_datum_tx_add_in_item_list(&l_tx, l_list_used_out);
        assert(EQUAL_256(l_value_to_items, l_value_transfer));
        dap_list_free_full(l_list_used_out, NULL);
    }
    // add 'out_cond' and 'out' items
    {
        uint256_t l_value_pack = {}; // how much coin add to 'out' items
        if(dap_chain_datum_tx_add_out_cond_item(&l_tx, a_pkey_cond_hash, a_srv_uid, a_value, a_value_per_unit_max, a_unit, a_cond,
                a_cond_size) == 1) {
            SUM_256_256(l_value_pack, a_value, &l_value_pack);
        } else {
            dap_chain_datum_tx_delete(l_tx);
            log_it( L_ERROR, "Cant add conditional output");
            return NULL;
        }
        // Network fee
        if (l_net_fee_used) {
            if (dap_chain_datum_tx_add_out_ext_item(&l_tx, &l_addr_fee, l_net_fee, a_net->pub.native_ticker) == 1)
                SUM_256_256(l_value_pack, l_net_fee, &l_value_pack);
            else {
                dap_chain_datum_tx_delete(l_tx);
                return NULL;
            }
        }
        // Validator's fee
        if (!IS_ZERO_256(a_value_fee)) {
            if (dap_chain_datum_tx_add_fee_item(&l_tx, a_value_fee) == 1)
                SUM_256_256(l_value_pack, a_value_fee, &l_value_pack);
            else {
                dap_chain_datum_tx_delete(l_tx);
                return NULL;
            }
        }
        // coin back
        uint256_t l_value_back = {};
        SUBTRACT_256_256(l_value_transfer, l_value_pack, &l_value_back);
        if (!IS_ZERO_256(l_value_back)) {
            if (dap_chain_datum_tx_add_out_ext_item(&l_tx, &l_addr_from, l_value_back, a_net->pub.native_ticker) != 1) {
                dap_chain_datum_tx_delete(l_tx);
                log_it( L_ERROR, "Cant add coin back output");
                return NULL;
            }
        }
    }

    // add 'sign' items
    if(dap_chain_datum_tx_add_sign_item(&l_tx, a_key_from) != 1) {
        dap_chain_datum_tx_delete(l_tx);
        log_it( L_ERROR, "Can't add sign output");
        return NULL;
    }
    size_t l_tx_size = dap_chain_datum_tx_get_size( l_tx );
    dap_chain_datum_t *l_datum = dap_chain_datum_create( DAP_CHAIN_DATUM_TX, l_tx, l_tx_size );
    dap_chain_datum_tx_delete(l_tx);
    dap_chain_t *l_chain = dap_chain_net_get_default_chain_by_chain_type(a_net, CHAIN_TYPE_TX);
    char *l_ret = dap_chain_mempool_datum_add(l_datum, l_chain, a_hash_out_type);
    DAP_DELETE(l_datum);
    return l_ret;
}


dap_chain_datum_token_emission_t *dap_chain_mempool_emission_get(dap_chain_t *a_chain, const char *a_emission_hash_str)
{
    dap_chain_datum_t *l_emission = dap_chain_mempool_datum_get(a_chain, a_emission_hash_str);
    if (!l_emission || l_emission->header.type_id != DAP_CHAIN_DATUM_TOKEN_EMISSION)
        return NULL;
    size_t l_emission_size = l_emission->header.data_size;
    dap_chain_datum_token_emission_t *l_ret = dap_chain_datum_emission_read(l_emission->data, &l_emission_size);
    DAP_DELETE(l_emission);
    return l_ret;
}

dap_chain_datum_t *dap_chain_mempool_datum_get(dap_chain_t *a_chain, const char *a_datum_hash_str)
{
    size_t l_datum_size;
    char *l_gdb_group = dap_chain_mempool_group_new(a_chain);
    dap_chain_datum_t *l_datum = (dap_chain_datum_t *)dap_global_db_get_sync(l_gdb_group,
                                                    a_datum_hash_str, &l_datum_size, NULL, NULL );
    if (!l_datum) {
        char *l_datum_hash_str_base58 = dap_enc_base58_to_hex_str_from_str(a_datum_hash_str);
        l_datum = (dap_chain_datum_t *)dap_global_db_get_sync(l_gdb_group,
                                    l_datum_hash_str_base58, &l_datum_size, NULL, NULL );
        DAP_DELETE(l_datum_hash_str_base58);
    }
    DAP_DELETE(l_gdb_group);
    
    if (l_datum_size >= sizeof(dap_chain_datum_t) && l_datum_size == dap_chain_datum_size(l_datum))
        return l_datum;
    DAP_DEL_Z(l_datum);
    return NULL;
}

dap_chain_datum_token_emission_t *dap_chain_mempool_datum_emission_extract(dap_chain_t *a_chain, byte_t *a_data, size_t a_size)
{
    if (!a_chain || !a_data || a_size < sizeof(dap_chain_datum_t))
        return NULL;
    dap_chain_datum_t *l_datum = (dap_chain_datum_t *)a_data;
    if ((l_datum->header.version_id != DAP_CHAIN_DATUM_VERSION) || (l_datum->header.type_id != DAP_CHAIN_DATUM_TOKEN_EMISSION) ||
            ((l_datum->header.data_size + sizeof(l_datum->header)) != a_size))
        return NULL;
    dap_chain_datum_token_emission_t *l_emission = (dap_chain_datum_token_emission_t *)l_datum->data;
    if (l_emission->hdr.type != DAP_CHAIN_DATUM_TOKEN_EMISSION_TYPE_AUTH)
        return NULL;
    if (!l_emission->data.type_auth.signs_count)
        return NULL;
    char *l_ticker = l_emission->hdr.ticker;
    if (l_ticker[DAP_CHAIN_TICKER_SIZE_MAX - 1])
        return NULL;
    dap_chain_net_t *l_net = dap_chain_net_by_name(a_chain->net_name);
    if (!l_net)
        return NULL;
    dap_chain_datum_token_t *l_token = dap_ledger_token_ticker_check(l_net->pub.ledger, l_ticker);
    if (!l_token)
        return NULL;
    if (l_token->subtype != DAP_CHAIN_DATUM_TOKEN_SUBTYPE_NATIVE && l_token->type == DAP_CHAIN_DATUM_TOKEN_TYPE_DECL)
        return NULL;
    /*int l_signs_valid = 0;
    dap_sign_t *l_ems_sign = (dap_sign_t *)(l_emission->tsd_n_signs + l_emission->data.type_auth.tsd_total_size);
    for (int i = 0; i < l_emission->data.type_auth.signs_count; i++) {
        uint32_t l_ems_pkey_size = l_ems_sign->header.sign_pkey_size;
        dap_sign_t *l_token_sign = (dap_sign_t *)(l_token->tsd_n_signs + l_token->header_native_decl.tsd_total_size);
        for (int j = 0; j < l_token->signs_total; j++) {
            if (l_ems_pkey_size == l_ems_sign->header.sign_pkey_size &&
                    !memcmp(l_token_sign->pkey_n_sign, l_ems_sign->pkey_n_sign, l_ems_pkey_size)) {
                l_signs_valid++;
                break;
            }
            l_token_sign = (dap_sign_t *)((byte_t *)l_token_sign + dap_sign_get_size(l_token_sign));
        }
        l_ems_sign = (dap_sign_t *)((byte_t *)l_ems_sign + dap_sign_get_size(l_ems_sign));
    }
    if (l_signs_valid != l_emission->data.type_auth.signs_count)
        return NULL;*/
    return DAP_DUP_SIZE(l_emission, l_datum->header.data_size);
}

/**
 * @breif dap_chain_mempool_filter
 * @param a_chain chain whose mempool will be filtered.
 * @param a_removed Pointer to a variable of type int which will store how many remote datums.
 */
void dap_chain_mempool_filter(dap_chain_t *a_chain, int *a_removed){
    if (!a_chain) {
        if (a_removed)
            *a_removed = 0;
        return;
    }
    int l_removed = 0;
    char * l_gdb_group = dap_chain_mempool_group_new(a_chain);
    size_t l_objs_size = 0;
    dap_time_t l_cut_off_time = dap_time_now() - 3 * 24 * 3600; // 3 days
    char l_cut_off_time_str[DAP_TIME_STR_SIZE] = {'\0'};
    dap_time_to_str_rfc822(l_cut_off_time_str, DAP_TIME_STR_SIZE, l_cut_off_time);
    dap_global_db_obj_t * l_objs = dap_global_db_get_all_sync(l_gdb_group, &l_objs_size);
    for (size_t i = 0; i < l_objs_size; i++) {
        dap_chain_datum_t *l_datum = (dap_chain_datum_t*)l_objs[i].value;
        if (!l_datum) {
            l_removed++;
            log_it(L_NOTICE, "Removed datum from mempool with \"%s\" key group %s: empty (possibly trash) value", l_objs[i].key, l_gdb_group);
            dap_global_db_del_sync(l_gdb_group, l_objs[i].key);
            continue;
        }
        size_t l_datum_size = dap_chain_datum_size(l_datum);
        //Filter data size
        if (l_datum_size != l_objs[i].value_len) {
            l_removed++;
            log_it(L_NOTICE, "Removed datum from mempool with \"%s\" key group %s. The size of the datum defined by the "
                             "function and the size specified in the record do not match.", l_objs[i].key, l_gdb_group);
            dap_global_db_del_sync(l_gdb_group, l_objs[i].key);
            continue;
        }
        //Filter hash
        if (dap_strcmp(dap_get_data_hash_str(l_datum->data, l_datum->header.data_size).s, l_objs[i].key) != 0) {
            l_removed++;
            log_it(L_NOTICE, "Removed datum from mempool with \"%s\" key group %s. The hash of the contents of the "
                             "datum does not match the key.", l_objs[i].key, l_gdb_group);
            dap_global_db_del_sync(l_gdb_group, l_objs[i].key);
            continue;
        }
        //Filter time
        if (l_datum->header.ts_create < l_cut_off_time) {
            l_removed++;
            log_it(L_NOTICE, "Removed datum from mempool with \"%s\" key group %s. The datum in the mempool was "
                             "created after the %s.", l_objs[i].key, l_gdb_group, l_cut_off_time_str);
            dap_global_db_del_sync(l_gdb_group, l_objs[i].key);
        }
        //Filter size decree
        if (l_datum->header.type_id == DAP_CHAIN_DATUM_DECREE) {
            size_t l_decree_size = dap_chain_datum_decree_get_size((dap_chain_datum_decree_t*)l_datum->data);
            if (l_datum->header.data_size != l_decree_size) {
                l_removed++;
                log_it(L_NOTICE, "Removed datum from mempool with \"%s\" key group %s. Decree datums do not have a "
                                 "valid size.", l_objs[i].key, l_gdb_group);
                dap_global_db_del_sync(l_gdb_group, l_objs[i].key);
            }
        }
    }
    dap_global_db_objs_delete(l_objs, l_objs_size);
    log_it(L_NOTICE, "Filter removed: %i records.", l_removed);
    DAP_DELETE(l_gdb_group);
}

/**
  * @brief Compose a transaction with event item for ledger event system
  * @param[in] a_chain Chain to create transaction for
  * @param[in] a_key_from Private key for signing
  * @param[in] a_service_key Service key for signing
  * @param[in] a_group_name Event group name
  * @param[in] a_event_type Event type
  * @param[in] a_event_data Event data
  * @param[in] a_event_data_size Size of event data
  * @param[in] a_fee_value Fee value
  * @param[in] a_hash_out_type Hash output format
  * @return Transaction hash string on success, NULL on error
  */
 char *dap_chain_mempool_tx_create_event(dap_chain_t *a_chain,
                               dap_enc_key_t *a_key_from,
                               dap_enc_key_t *a_service_key,
                               dap_chain_srv_uid_t a_srv_uid,
                               const char *a_group_name,
                               uint16_t a_event_type,
                               const void *a_event_data,
                               size_t a_event_data_size,
                               uint256_t a_fee_value,
                               const char *a_hash_out_type)
 {
    // Validate input parameters using standard cellframe pattern
    dap_return_val_if_fail(a_chain && a_key_from && a_service_key && a_hash_out_type, NULL);
    dap_return_val_if_fail(a_group_name && strlen(a_group_name), NULL);
    dap_return_val_if_fail((a_event_data != NULL) == (a_event_data_size > 0), NULL);
    dap_return_val_if_fail(a_key_from->priv_key_data && a_key_from->priv_key_data_size, NULL);
    dap_return_val_if_fail(a_service_key->priv_key_data && a_service_key->priv_key_data_size, NULL);

    const char *l_native_ticker = dap_chain_net_by_id(a_chain->net_id)->pub.native_ticker;

    // Calculate total fees needed
    uint256_t l_net_fee = {}, l_total_fee = a_fee_value, l_fee_transfer = {};
    dap_chain_addr_t l_addr_fee = {};
    dap_list_t *l_list_fee_out = NULL;

    bool l_net_fee_used = dap_chain_net_tx_get_fee(a_chain->net_id, &l_net_fee, &l_addr_fee);
    if (l_net_fee_used)
        SUM_256_256(l_total_fee, l_net_fee, &l_total_fee);
    if (IS_ZERO_256(l_total_fee)) {
        log_it(L_ERROR, "Total fee is zero");
        return NULL;
    }
     
    // Get ledger for wallet operations
    dap_ledger_t *l_ledger = dap_chain_net_by_id(a_chain->net_id)->pub.ledger;

    dap_chain_addr_t l_addr_from = {};
    dap_chain_addr_fill_from_key(&l_addr_from, a_key_from, a_chain->net_id);

    // Find outputs to cover fees (following mempool style)

    l_list_fee_out = dap_chain_wallet_get_list_tx_outs_with_val(l_ledger, l_native_ticker,
                                                        &l_addr_from, l_total_fee, 
                                                        &l_fee_transfer);
    if (!l_list_fee_out) {
        log_it(L_WARNING, "Not enough funds to pay fee");
        return NULL;
    }
 
    // Create empty transaction
    dap_chain_datum_tx_t *l_tx = dap_chain_datum_tx_create();
    if (!l_tx) {
        log_it(L_ERROR, "Failed to create transaction");
        dap_list_free_full(l_list_fee_out, NULL);
        return NULL;
    }

    // Add 'in' items
    uint256_t l_value_fee_items = dap_chain_datum_tx_add_in_item_list(&l_tx, l_list_fee_out);
    assert(EQUAL_256(l_value_fee_items, l_fee_transfer));
    dap_list_free_full(l_list_fee_out, NULL);

    // Create and add event item using standard cellframe function
    dap_chain_tx_item_event_t *l_event_item = dap_chain_datum_tx_event_create(a_srv_uid, a_group_name, a_event_type, dap_time_now());
    if (!l_event_item) {
        log_it(L_ERROR, "Failed to create event item");
        dap_chain_datum_tx_delete(l_tx);
        return NULL;
    }
    if (dap_chain_datum_tx_add_item(&l_tx, l_event_item) != 1) {
        log_it(L_ERROR, "Failed to add event item to transaction");
        DAP_DELETE(l_event_item);
        dap_chain_datum_tx_delete(l_tx);
        return NULL;
    }

    // Add TSD section with event data if provided
    if (a_event_data && a_event_data_size > 0) {
        // Create TSD section with event data using standard cellframe function
        dap_chain_tx_tsd_t *l_tsd_item = dap_chain_datum_tx_item_tsd_create(
            (void *)a_event_data, DAP_CHAIN_TX_TSD_TYPE_EVENT_DATA, a_event_data_size);
        
        if (!l_tsd_item) {
            log_it(L_ERROR, "Failed to create TSD item with event data");
            dap_chain_datum_tx_delete(l_tx);
            return NULL;
        }
        
        int l_result = dap_chain_datum_tx_add_item(&l_tx, (const void *)l_tsd_item);
        DAP_DELETE(l_tsd_item);
        
        if (l_result != 1) {
            log_it(L_ERROR, "Failed to add TSD item to transaction: %d", l_result);
            dap_chain_datum_tx_delete(l_tx);
            return NULL;
        }
    }

    // Add network fee output if used
    if (l_net_fee_used) {
        if (dap_chain_datum_tx_add_out_ext_item(&l_tx, &l_addr_fee, l_net_fee, l_native_ticker) != 1) {
            log_it(L_ERROR, "Failed to add network fee output");
            dap_chain_datum_tx_delete(l_tx);
            return NULL;
        }
    }

    // Add validator's fee
    if (!IS_ZERO_256(a_fee_value)) {
        if (dap_chain_datum_tx_add_fee_item(&l_tx, a_fee_value) != 1) {
            log_it(L_ERROR, "Failed to add validator fee");
            dap_chain_datum_tx_delete(l_tx);
            return NULL;
        }
    }

    // Calculate and add change output
    uint256_t l_value_back = {};   
    SUBTRACT_256_256(l_fee_transfer, l_total_fee, &l_value_back);

    // Add change output if needed
    if (!IS_ZERO_256(l_value_back)) {
        if (dap_chain_datum_tx_add_out_ext_item(&l_tx, &l_addr_from, l_value_back, l_native_ticker) != 1) {
            log_it(L_ERROR, "Failed to add change output");
            dap_chain_datum_tx_delete(l_tx);
            return NULL;
        }
    }

    // Add signature
    if (dap_chain_datum_tx_add_sign_item(&l_tx, a_key_from) != 1) {
        log_it(L_ERROR, "Failed to sign transaction");
        dap_chain_datum_tx_delete(l_tx);
        return NULL;
    }

    // Add second signature from service key
    if (dap_chain_datum_tx_add_sign_item(&l_tx, a_service_key) != 1) {
        log_it(L_ERROR, "Failed to add service signature to transaction");
        dap_chain_datum_tx_delete(l_tx);
        return NULL;
    }

    size_t l_tx_size = dap_chain_datum_tx_get_size(l_tx);

    // Create datum and add to mempool (following mempool pattern)
    dap_chain_datum_t *l_datum = dap_chain_datum_create(DAP_CHAIN_DATUM_TX, l_tx, l_tx_size);
    dap_chain_datum_tx_delete(l_tx);
    
    if (!l_datum) {
        log_it(L_ERROR, "Failed to create transaction datum");
        return NULL;
    }

    // Add to mempool
    char *l_ret = dap_chain_mempool_datum_add(l_datum, a_chain, a_hash_out_type);
    DAP_DELETE(l_datum);
    
    if (!l_ret) {
        log_it(L_ERROR, "Failed to add event transaction to mempool");
        return NULL;
    }
    
    log_it(L_INFO, "Successfully composed and added event transaction to mempool: %s", l_ret);
    return l_ret;
}

bool dap_chain_mempool_out_is_used(dap_chain_net_t *a_net, dap_hash_fast_t *a_out_hash, uint32_t a_out_idx)
{
    char *l_gdb_group_mempool = dap_chain_net_get_gdb_group_mempool_by_chain_type(a_net, CHAIN_TYPE_TX);
    if(!l_gdb_group_mempool){
        log_it(L_ERROR, "%s: mempool group not found\n", a_net->pub.name);
        return false;
    }
    size_t l_objs_count = 0;
    dap_global_db_obj_t * l_objs = dap_global_db_get_all_sync(l_gdb_group_mempool, &l_objs_count);
    for (size_t i = 0; i < l_objs_count; i++) {
        dap_chain_datum_t *l_datum = (dap_chain_datum_t*)l_objs[i].value;
        if (!l_datum || l_datum->header.type_id != DAP_CHAIN_DATUM_TX) {
            continue;
        }
        dap_chain_datum_tx_t *l_datum_tx = (dap_chain_datum_tx_t*)l_datum->data;
        byte_t *l_item; size_t l_size; int index, l_out_idx = 0;
        TX_ITEM_ITER_TX_TYPE(l_item, TX_ITEM_TYPE_IN_ALL, l_size, index, l_datum_tx) {
            if (*l_item != TX_ITEM_TYPE_IN && *l_item != TX_ITEM_TYPE_IN_COND) {
                continue;
            }
            dap_chain_tx_in_t *l_tx_in = (dap_chain_tx_in_t*)l_item;
            if (l_tx_in->header.tx_out_prev_idx == a_out_idx && dap_hash_fast_compare(&l_tx_in->header.tx_prev_hash, a_out_hash)) {
                dap_global_db_objs_delete(l_objs, l_objs_count);
                return true;
            }
        }
    }
    dap_global_db_objs_delete(l_objs, l_objs_count);
    return false;
}

 /**
  * @brief Compose a transaction with event item for ledger event system
  * @param[in] a_chain Chain to create transaction for
  * @param[in] a_key_from Private key for signing
  * @param[in] a_service_key Service key for signing
  * @param[in] a_group_name Event group name
  * @param[in] a_event_type Event type
  * @param[in] a_event_data Event data
  * @param[in] a_event_data_size Size of event data
  * @param[in] a_fee_value Fee value
  * @param[in] a_hash_out_type Hash output format
  * @return Transaction hash string on success, NULL on error
  */
  char *dap_chain_mempool_tx_create_service_decree(dap_chain_t *a_chain, dap_enc_key_t *a_key_from,
                                                   dap_enc_key_t *a_service_key, dap_chain_srv_uid_t a_srv_uid,
                                                    const void *a_service_decree_data,
                                                    size_t a_service_decree_data_size,
                                                    uint256_t a_fee_value,
                                                    const char *a_hash_out_type)
{
    return dap_chain_mempool_tx_create_event(a_chain, a_key_from, a_service_key, a_srv_uid, "SERVICE_DECREE", DAP_CHAIN_TX_EVENT_TYPE_SERVICE_DECREE,
                                             a_service_decree_data, a_service_decree_data_size, a_fee_value, a_hash_out_type);
}
/**
 * @brief Get mempool group name for chain
 * @param a_chain Chain pointer
 * @return Group name string (must be freed by caller) or NULL on error
 */
char *dap_chain_mempool_group_new(dap_chain_t *a_chain)
{
    dap_chain_net_t *l_net = a_chain ? dap_chain_net_by_id(a_chain->net_id) : NULL;
    return l_net
            ? dap_chain_mempool_group_name(l_net->pub.gdb_groups_prefix, a_chain->name)
            : NULL;
}

